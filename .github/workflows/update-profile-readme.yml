name: Update Profile README

on:
  schedule:
    - cron: '0 0 * * 0'  # Runs weekly on Sunday at midnight
  workflow_dispatch:  # Allows manual triggering

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout profile repository
        uses: actions/checkout@v3
        with:
          path: profile-repo
          repository: dougzilla32/dougzilla32
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: pip install pygithub

      - name: Generate README from repositories
        env:
          GITHUB_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        run: |
          cat > update_readme.py << 'EOF'
          import os
          import re
          from github import Github
          import base64
          from datetime import datetime, timezone
          import glob
          from difflib import SequenceMatcher
          from collections import defaultdict

          # Initialize GitHub client
          token = os.environ['GITHUB_TOKEN']
          g = Github(token)
          user = g.get_user()

          def calculate_significance(repo):
              # Base score
              score = 0
              
              # Stars have high weight
              score += repo.stargazers_count * 10
              
              # Forks have medium weight
              score += repo.forks_count * 5
              
              # Recent activity (higher for newer repos)
              if repo.updated_at:
                  # Calculate days since last update
                  days_since_update = (datetime.now(timezone.utc) - 
                                      repo.updated_at).days
                  # More recent updates get higher scores (max 100)
                  score += max(0, 100 - days_since_update)
              
              # Size has some weight
              score += min(100, repo.size / 1000)  # Cap at 100 points for size
              
              # Custom tag in topics can override
              if 'significance:high' in repo.get_topics():
                  score += 1000
              elif 'significance:medium' in repo.get_topics():
                  score += 500
              elif 'significance:low' in repo.get_topics():
                  score -= 500
              
              # Private repos might be more significant for professional work
              if repo.private:
                  score += 50
              
              return score

          def get_base_name(repo_name):
              # Strip common prefixes/suffixes and extract the core name
              # This helps group repositories like SweepData, SweepNPark, etc.
              
              # Extract the first word or prefix that could be used for grouping
              # For camelCase or PascalCase names, find the first word
              matches = re.findall(r'[A-Z][a-z0-9]+', repo_name)
              if matches:
                  return matches[0]
              
              # For hyphenated names, use the first part
              if '-' in repo_name:
                  return repo_name.split('-')[0]
              
              # Default to the first 5 characters if no pattern matches
              return repo_name[:5] if len(repo_name) > 5 else repo_name

          def title_matches_repo_name(title, repo_name):
              # Check if the title meaningfully matches the repository name
              # Using string similarity and common word detection
              
              # Clean up strings for comparison
              title_clean = re.sub(r'[^\w\s]', '', title.lower())
              repo_clean = re.sub(r'[^\w\s]', '', repo_name.lower())
              
              # Extract words
              title_words = set(title_clean.split())
              repo_words = set(re.findall(r'[A-Z]?[a-z]+', repo_name))
              repo_words = {word.lower() for word in repo_words}
              
              # If there's significant word overlap, consider it a match
              if len(repo_words.intersection(title_words)) > 0:
                  return True
                  
              # Calculate string similarity
              similarity = SequenceMatcher(None, title_clean, repo_clean).ratio()
              
              # If title contains repository name, it's a match
              if repo_clean in title_clean:
                  return True
                  
              # If strings are similar enough, consider it a match
              if similarity > 0.4:  # Threshold can be adjusted
                  return True
                  
              return False

          # Create directory for individual READMEs if it doesn't exist
          project_readmes_dir = 'profile-repo/project-readmes'
          os.makedirs(project_readmes_dir, exist_ok=True)

          # Track repositories to know which README files should be kept
          all_repo_names = set()
          private_repo_names = set()

          # Get all repositories, filter and calculate significance
          repos_with_data = []
          for repo in user.get_repos():
              # Skip repositories that are:
              # 1. Without description
              # 2. The profile repository
              # 3. Forked repositories
              if not repo.description or repo.name == 'dougzilla32' or repo.fork:
                  continue
                  
              # Check if repository has a README
              try:
                  readme_file = repo.get_readme()
                  readme_content = base64.b64decode(readme_file.content).decode('utf-8')
              except:
                  # Skip repositories without README
                  print(f"Skipping {repo.name}: No README found")
                  continue
                  
              all_repo_names.add(repo.name)
              if repo.private:
                  private_repo_names.add(repo.name)
                  
              # Calculate significance score
              significance = calculate_significance(repo)
              
              # Get base name for grouping
              base_name = get_base_name(repo.name)
              
              repos_with_data.append((repo, significance, base_name, readme_content))
              
          # Group repositories by base name
          repos_by_base_name = defaultdict(list)
          for repo, significance, base_name, readme_content in repos_with_data:
              repos_by_base_name[base_name].append((repo, significance, readme_content))
          
          # Sort base name groups by their highest significance score
          base_names_by_significance = []
          for base_name, repos in repos_by_base_name.items():
              max_significance = max(sig for _, sig, _ in repos)
              base_names_by_significance.append((base_name, max_significance))
          
          # Sort base names by their highest significance score
          base_names_by_significance.sort(key=lambda x: x[1], reverse=True)
          
          # Start building the main README content
          main_readme = f"# Doug Stein's GitHub Projects\n\n"
          main_readme += "Welcome to my GitHub profile! Below you'll find descriptions of my projects, including private repositories. "
          main_readme += "For public repositories, links go directly to the GitHub repository. "
          main_readme += "For private repositories, links go to documentation stored in this profile repository.\n\n"
          main_readme += "## Projects\n\n"
          
          # Process each group of repositories in order of significance
          for base_name, _ in base_names_by_significance:
              repos_in_group = repos_by_base_name[base_name]
              
              # Sort repositories within this group by significance
              repos_in_group.sort(key=lambda x: x[1], reverse=True)
              
              # Process each repository in this group
              for repo, significance, readme_content in repos_in_group:
                  try:
                      # Get the repository description from the About section
                      description = repo.description
                      
                      # Get repository topics/tags
                      topics = repo.get_topics()
                      
                      # Default title is the repository name
                      title = repo.name
                      
                      # Strip any leading whitespace to find the first real line
                      readme_content_stripped = readme_content.lstrip()
                      
                      # Check if the first line is a # title
                      if readme_content_stripped.startswith('# '):
                          # Extract title from the first line
                          first_line_end = readme_content_stripped.find('\n')
                          if first_line_end > 0:
                              potential_title = readme_content_stripped[2:first_line_end].strip()
                              # Only use the title if it somewhat matches the repo name
                              if title_matches_repo_name(potential_title, repo.name):
                                  title = potential_title
                                  print(f"Using title from README for {repo.name}: '{title}'")
                              else:
                                  print(f"Title doesn't match for {repo.name}: '{potential_title}'")
                      
                      # Add to main README
                      if repo.private:
                          # For private repos, link to local copy
                          main_readme += f"### [{title}](./project-readmes/{repo.name}.md)\n\n"
                      else:
                          # For public repos, link directly to GitHub
                          main_readme += f"### [{title}]({repo.html_url})\n\n"
                      
                      main_readme += f"{description}\n\n"
                      
                      if topics:
                          main_readme += 'Technologies: ' + ', '.join(f'`{topic}`' for topic in topics) + '\n\n'
                          
                      # Note if it's private (without the "documentation available" text)
                      if repo.private:
                          main_readme += "> ðŸ”’ Private repository\n\n"
                      
                      # Only copy READMEs for private repositories
                      if repo.private:
                          # Modify the README content to include repository info at the top
                          repo_info = f"# {title}\n\n"
                          repo_info += f"{description}\n\n"
                          repo_info += "> ðŸ”’ Private Repository\n\n"
                          
                          if topics:
                              repo_info += 'Technologies: ' + ', '.join(f'`{topic}`' for topic in topics) + '\n\n'
                              
                          repo_info += "---\n\n"
                          
                          # Check if the first real line is a title
                          if readme_content_stripped.startswith('# '):
                              first_line_end = readme_content_stripped.find('\n')
                              # Replace just the first title line
                              if first_line_end > 0:
                                  first_title_line = readme_content_stripped[:first_line_end+1]
                                  modified_readme = readme_content.replace(first_title_line, repo_info, 1)
                              else:
                                  modified_readme = repo_info + readme_content[2:]  # Skip the # 
                          else:
                              # No title at the start, just prepend our info
                              modified_readme = repo_info + readme_content
                          
                          with open(f'{project_readmes_dir}/{repo.name}.md', 'w') as f:
                              f.write(modified_readme)
                              
                  except Exception as e:
                      print(f"Error processing {repo.name}: {str(e)}")
                      continue
              
              # Add a divider after each group (except the last)
              if base_name != base_names_by_significance[-1][0]:
                  main_readme += "---\n\n"

          # Cleanup: Remove README files for repositories that no longer exist or are public
          # List all markdown files in the project_readmes directory
          existing_readme_files = glob.glob(f'{project_readmes_dir}/*.md')
          for readme_file in existing_readme_files:
              # Extract the repository name from the filename
              repo_name = os.path.basename(readme_file).replace('.md', '')
              
              # If the file is for a public repository or a repository that no longer exists, remove it
              if repo_name not in private_repo_names:
                  print(f"Removing README for public or removed repository: {repo_name}")
                  os.remove(readme_file)

          # Add footer to main README
          main_readme += f"\n\n*Last updated: {datetime.now().strftime('%Y-%m-%d')}*\n"
          main_readme += "\n\nThis profile is automatically generated from my repository information"

          # Write the main README file
          with open('profile-repo/README.md', 'w') as f:
              f.write(main_readme)
              
          # Print some info about the significance scores and grouping for debugging
          print("\nRepository Groups by Significance:")
          for base_name, max_score in base_names_by_significance:
              print(f"\nGroup: {base_name} (Max Significance: {max_score})")
              group_repos = repos_by_base_name[base_name]
              group_repos.sort(key=lambda x: x[1], reverse=True)
              for repo, score, _ in group_repos:
                  print(f"  - {repo.name}: {score}")
                  
          print(f"\nTotal repositories included: {len(repos_with_data)}")
          print(f"Private repositories included: {len(private_repo_names)}")
          EOF
          
          python update_readme.py

      - name: Commit and push if changed
        run: |
          cd profile-repo
          git config user.name 'github-actions[bot]'
          git config user.email 'github-actions[bot]@users.noreply.github.com'
          git add README.md project-readmes/
          git diff --quiet && git diff --staged --quiet || git commit -m "Update profile README and project documentation"
          git push